/**
 * Autogenerator for Client code
 */
import {initCap, propertyToType, toCamelCase} from "../util";

const HEADER: string = `/**\n * This file is automatically generated.\n * Do not modify this file, any changes will be overwritten.\n *\n * Generated ${new Date()}\n */\n\n`;

export function generateClients(clientDirectory: string, openApi: any) {
  const fs = require('fs');
  const tags: any = {};
  const paths = openApi.paths;

  fs.mkdirSync(clientDirectory, { recursive: true });

  console.log(`Generating NestJS Clients to ${clientDirectory}:`);

  for (const tag of openApi.tags) {
    tags[tag.name] = tag;
    tags[tag.name].paths = [];
  }

  // Step 1: prepare a list of all paths associated with a tag.
  for (const path of Object.keys(paths)) {
    for (const [pathMethod, pathMethodData] of Object.entries(paths[path])) {
      for (const tag of pathMethodData['tags']) {
        tags[tag].paths.push({
          path,
          method: pathMethod,
          data: pathMethodData
        });
      }
    }
  }

  // Step 2: walk the list of tags, and write all controllers for each tag
  for (const tag of Object.keys(tags)) {
    const controllerName = tags[tag].name;
    const controllerDescription = tags[tag].description ?? '';

    generateClient(clientDirectory, controllerName, controllerDescription, tags[tag].paths);
  }

  // Write index
  let indexBody = HEADER;
  const indexFilename = `${clientDirectory}/index.ts`;

  for(const tag of Object.keys(tags)) {
    indexBody += `export * from './${tag}.client';\n`;
  }

  fs.writeFileSync(indexFilename, indexBody, 'utf8');
  console.log(`  + Wrote ${indexFilename}`);
}

function generateClient(directory: string, name: string, description: string, paths: any[]) {
  const fs = require('fs');
  const serviceFile = `${directory}/${name}.client.ts`;
  const serviceDtoImports = {};
  let serviceBody = '';
  let serviceClassBody = '';
  let serviceImports = '';

  serviceBody += HEADER;

  for (const pathEntry of paths) {
    const { path, method } = pathEntry;
  //   const { operationId, description, summary, parameters, requestBody, responses } = pathEntry.data;
    const { operationId, description, responses, parameters, requestBody, } = pathEntry.data;
    const requestBodyContent = requestBody?.content['application/json'];
    const inputs = [];
    const inputVariables = [];
    const inputVariableNames: string[] = [];
    const alteredPath = path.replaceAll('{', '${');
  //   let returnType = null;

    serviceClassBody += '/**\n';
    serviceClassBody += ` * ${description.trim().replaceAll('\n', '\n   * ')}\n`;
    serviceClassBody += ' *\n';

  //   for (const [ responseCode, responseData ] of Object.entries(responses)) {
  //     const responseDescription = responseData['description'] ?? '';
  //
  //     if (responseData['content']) {
  //       const content = responseData['content'];
  //       const contentCode = parseInt(responseCode);
  //       const contentTypes = Object.keys(content);
  //
  //       if (contentCode >= 200 && contentCode <= 299) {
  //         const contentSchema = content[contentTypes[0]].schema;
  //         const contentSchemaType = propertyToType(contentSchema);
  //
  //         if (contentTypes.length > 1) {
  //           throw new Error(`Path ${path}, method ${method}, return code ${contentCode} has more than one content type for operation ${operationId}`);
  //         }
  //
  //         if (returnType) {
  //           returnType += ` | ${contentSchemaType}`;
  //         } else {
  //           returnType = contentSchemaType;
  //         }
  //
  //         if (contentSchemaType.endsWith('Dto')) {
  //           serviceDtoImports[contentSchemaType] = 1;
  //         } else if (contentSchemaType.indexOf('[')) {
  //           if (contentSchemaType.substring(0, contentSchemaType.indexOf('[')).endsWith('Dto')) {
  //             serviceDtoImports[contentSchemaType.substring(0, contentSchemaType.indexOf('['))] = 1;
  //           }
  //         }
  //       }
  //     }
  //   }

    for (const [ responseCode, responseData ] of Object.entries(responses)) {
      const responseDescription = responseData['description'] ?? '';

      serviceClassBody += ` * - Response code '${responseCode}': '${responseDescription.trim().replaceAll('\n', ' ')}'\n`;
    }

    serviceClassBody += ` *\n * Service path: '${path}', Verb: '${method}'\n * \n`;

    if (parameters) {
      for (const parameter of parameters) {
        const { name, description, schema } = parameter;
        const inPath = parameter.in;

        if (inPath.toLowerCase() === 'path') {
          const parameterSchema = propertyToType(schema);

          if (parameterSchema.endsWith('Dto')) {
            serviceDtoImports[parameterSchema] = 1;
          } else if (parameterSchema.indexOf('[')) {
            if (parameterSchema.substring(0, parameterSchema.indexOf('[')).endsWith('Dto')) {
              serviceDtoImports[parameterSchema.substring(0, parameterSchema.indexOf('['))] = 1;
            }
          }

          if (description) {
            serviceClassBody += ` * @param ${name} ${description}\n`;
          } else {
            serviceClassBody += ` * @param ${name} (undocumented input parameter)\n`;
          }

          inputs.push(`@Param('${name}') ${name}: ${parameterSchema}`);
          inputVariables.push(`${name}: ${parameterSchema}`);
          inputVariableNames.push(name);
        }
      }
    }

    if (requestBodyContent) {
      const schema = requestBodyContent.schema;

      if (schema.$ref) {
        const reference = schema.$ref.substring(schema.$ref.lastIndexOf('/') + 1);

        inputs.push(`@Body() ${toCamelCase(reference)}Dto: ${reference}Dto`);
        inputVariables.push(`${toCamelCase(reference)}Dto: ${reference}Dto`);
        serviceDtoImports[`${reference}Dto`] = 1;
        inputVariableNames.push(`${toCamelCase(reference)}Dto`);

        if (requestBody.description) {
          serviceClassBody += ` * @param ${toCamelCase(reference)}Dto ${requestBody.description}\n`;
        }
      }
    }

    inputVariables.push('headers?: any')

    const modifiedPath = path.replaceAll('{', '${');

    serviceClassBody += ' * @param headers Any optional additional headers to send along with the request\n';
    serviceClassBody += ' */\n';
    serviceClassBody += `export const ${initCap(name)}${initCap(operationId)} = async (${inputVariables.join(', ')},) => {\n`;

    serviceClassBody += `  console.log(\`Requesting ${path}\`);\n\n`;
    serviceClassBody += '  const config = {\n';
    serviceClassBody += '    headers: {\n';
    serviceClassBody += '      ...headers,\n';
    serviceClassBody += '      \'Content-Type\': \'application/json\',\n';
    serviceClassBody += '    },\n';
    serviceClassBody += '  };\n';

    if (method.toLowerCase() !== 'get' && method.toLowerCase() !== 'delete') {
      serviceClassBody += `  const postData = {\n`;
      serviceClassBody += inputVariableNames.map((x) => `    ${x}`).join(',\n');
      serviceClassBody += `,\n  };\n\n`;

      serviceClassBody += `  return axios.${method}(\`${modifiedPath}\`, postData, config)\n`;
    } else {
      serviceClassBody += `\n  return axios.${method}(\`${modifiedPath}\`, config)\n`;
    }

    serviceClassBody += '    .then((x) => x.data)\n';
    serviceClassBody += '    .catch((x) => {\n';
    serviceClassBody += '      console.error(\'Request failed\', x);\n';
    serviceClassBody += '      return Promise.reject(x);\n';
    serviceClassBody += '    });\n';
    serviceClassBody += '};\n\n';
  }

  if (Object.keys(serviceDtoImports).length > 0) {
    serviceImports += `import { ${Object.keys(serviceDtoImports).join(', ')} } from '../dto';\n`;
  }

  serviceImports += 'import axios from \'axios\';\n';

  serviceBody += serviceImports;
  serviceBody += '\n';
  serviceBody += serviceClassBody;

  fs.writeFileSync(serviceFile, serviceBody, 'utf8');
  console.log(`  - Wrote ${serviceFile}`);
}