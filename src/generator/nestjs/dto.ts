import {propertyToType, typeFormatter} from '../util';

const HEADER: string = `/**\n * This file is automatically generated.\n * Do not modify this file, any changes will be overwritten.\n *\n * Generated ${new Date()}\n */\n\n`;
const IMPORT_HEADER: string = 'import { ApiProperty, ApiPropertyOptional } from \'@nestjs/swagger\';\n\n';

export function generateDtos(dtoDirectory: string, openapi: any) {
  const schemas = openapi.components.schemas;
  const fs = require('fs');

  fs.mkdirSync(dtoDirectory, { recursive: true });

  console.log(`Generating NestJS DTO objects to ${dtoDirectory}:`);

  for(const dto of Object.keys(schemas)) {
    const { properties, description } = schemas[dto];
    const required: string[] = schemas[dto].required ?? [];
    const dtoName = `${dto}Dto`;
    const dtoFilename = `${dtoDirectory}/${dto}.dto.ts`;
    const dtoHeader = HEADER + IMPORT_HEADER;
    const schemaDump = JSON.stringify(properties, null, 2)
        .replaceAll('\n', '\n    ')
        .replace(/"([^"]+)":/g, '$1:');
    let dtoBody = '';

    // Add header to the class definition
    dtoBody += dtoHeader;
    dtoBody += `/**\n * ${description.trim().replaceAll('\n', '\n * ')}\n */\n`;
    dtoBody += `export class ${dtoName} {\n`;
    dtoBody += '  /**\n   * This is the schema that is used to generate the DTO class.\n   * It is also used for validation purposes.\n   */\n';
    dtoBody += `  public static schema: any = {\n`;
    dtoBody += '    type: "object",\n';

    if (required) {
      dtoBody += '    required: [ ';
      dtoBody += required.map((x: string) => `'${x}'`).join(', ');
      dtoBody += ' ],\n';
    }

    dtoBody += `    properties: ${schemaDump},\n`;
    dtoBody += '  };\n\n';

    for(const property of Object.keys(properties)) {
      // This converts the properties section of the @ApiProperty section, each key is converted to use
      // no quotes, as it matches the name of the property interface.
      const propertiesDump = JSON.stringify(properties[property], typeFormatter, 2)
        .replaceAll('\n', '\n  ')
        .replace(/"([^"]+)":/g, '$1:')
        .replaceAll('  type: "object",\n  ', '');
      let requiredFlag = required.includes(property) ? '' : '?';
      let optionalFlag = required.includes(property) ? 'ApiProperty' : 'ApiPropertyOptional';

      dtoBody += `  @${optionalFlag}(${propertiesDump.substring(0, propertiesDump.length - 1)}})\n`;
      dtoBody += `  ${property}${requiredFlag}: ${propertyToType(properties[property])};\n\n`;
    }

    // Add AJV validation
    dtoBody += '  /**\n   * Tests a payload against the schema for this DTO.\n   *\n   * @throws Error on failed validations.\n   */\n';
    dtoBody += `  public static validate(payload: ${dtoName}): boolean {\n`;
    dtoBody += '    const Ajv = require("ajv");\n';
    dtoBody += '    const addFormats = require("ajv-formats");\n';
    dtoBody += '    const ajv = new Ajv({ strict: false });\n\n';
    dtoBody += '    addFormats(ajv);\n\n';
    dtoBody += '    const validate = ajv.compile(this.schema);\n';
    dtoBody += '    return validate(payload);\n';
    dtoBody += '  }\n';
    dtoBody += '}\n';

    fs.writeFileSync(dtoFilename, dtoBody, 'utf8');
    console.log(`  - Wrote ${dtoFilename}`);
  }

  // Write index
  let indexBody = HEADER;
  const indexFilename = `${dtoDirectory}/index.ts`;

  for(const dto of Object.keys(schemas)) {
    indexBody += `export * from './${dto}.dto';\n`;
  }

  fs.writeFileSync(indexFilename, indexBody, 'utf8');
  console.log(`  - Wrote ${indexFilename}`);
}