import {initCap, propertyToType, toCamelCase} from "../util";

const HEADER: string = `/**\n * This file is automatically generated.\n * Do not modify this file, any changes will be overwritten.\n *\n * Generated ${new Date()}\n */\n\n`;

export function generateServices(serviceDirectory: string, openApi: any) {
  const fs = require('fs');
  const tags: any = {};
  const paths = openApi.paths;

  fs.mkdirSync(serviceDirectory, { recursive: true });

  console.log(`Generating NestJS Services to ${serviceDirectory}:`);

  for (const tag of openApi.tags) {
    tags[tag.name] = tag;
    tags[tag.name].paths = [];
  }

  // Step 1: prepare a list of all paths associated with a tag.
  for (const path of Object.keys(paths)) {
    for (const [pathMethod, pathMethodData] of Object.entries(paths[path])) {
      for (const tag of pathMethodData['tags']) {
        tags[tag].paths.push({
          path,
          method: pathMethod,
          data: pathMethodData
        });
      }
    }
  }

  // Step 2: walk the list of tags, and write all controllers for each tag
  for (const tag of Object.keys(tags)) {
    const controllerName = tags[tag].name;
    const controllerDescription = tags[tag].description ?? '';

    generateService(serviceDirectory, controllerName, controllerDescription, tags[tag].paths);
  }

  // Write index
  let indexBody = HEADER;
  const indexFilename = `${serviceDirectory}/index.ts`;

  indexBody += '/**\n';
  indexBody += ' * This type is used to describe the response of a service call.\n';
  indexBody += ' *\n';
  indexBody += ' * The return steps are as follows:\n';
  indexBody += ' * - If a status message is present, it will be returned, regardless of the status code.\n';
  indexBody += ' * - If a return value is present, it will be returned, regardless of the status code, or no content will be returned if not set.\n';
  indexBody += ' *\n';
  indexBody += ' * @param T This is the type of object that is returned when the service call is successful.\n';
  indexBody += ' * @param returnContentType This is the contentType of the return value, or status message - if present.\n';
  indexBody += ' * @param statusCode The status code of the response to return.\n';
  indexBody += ' * @param statusMessage If set, this will be returned in JSON.stringify format, and it will be treated as a return value on a failure.\n';
  indexBody += ' */\n';
  indexBody += 'export type ServiceResponse<T> = {\n';
  indexBody += '  returnValue: T,\n';
  indexBody += '  returnContentType: string,\n';
  indexBody += '  statusCode: number,\n';
  indexBody += '  statusMessage?: any,\n';
  indexBody += '  additionalCookies?: { [key: string]: string },\n';
  indexBody += '}\n\n';
  indexBody += 'export const ResponseOk = (val: any) => {\n';
  indexBody += '  return {'
  indexBody += '    returnValue: val,\n';
  indexBody += '    returnContentType: \'application/json\',\n';
  indexBody += '    statusCode: 200,\n';
  indexBody += '  };\n';
  indexBody += '}\n\n';
  indexBody += 'export const ResponseNoContent = () => {\n';
  indexBody += '  return {\n';
  indexBody += '    returnValue: null,\n';
  indexBody += '    returnContentType: \'application/json\',\n';
  indexBody += '    statusCode: 201,\n';
  indexBody += '  };\n';
  indexBody += '}\n\n';
  indexBody += 'export const ResponseCreated = (val: any | null = null) => {\n';
  indexBody += '  return {\n';
  indexBody += '    returnValue: val,\n';
  indexBody += '    returnContentType: \'application/json\',\n';
  indexBody += '    statusCode: 204,\n';
  indexBody += '  };\n';
  indexBody += '}\n\n';

  for(const tag of Object.keys(tags)) {
    indexBody += `export * from './${tag}.service';\n`;
  }

  fs.writeFileSync(indexFilename, indexBody, 'utf8');
  console.log(`  + Wrote ${indexFilename}`);
}

function generateService(directory: string, name: string, description: string, paths: any[]) {
  const fs = require('fs');
  const serviceFile = `${directory}/${name}.service.ts`;
  const serviceDtoImports = {};
  let serviceBody = '';
  let serviceClassBody = '';
  let serviceImports = '';

  serviceBody += HEADER;

  for (const pathEntry of paths) {
    const { path, method } = pathEntry;
    const { operationId, description, summary, parameters, requestBody, responses } = pathEntry.data;
    const requestBodyContent = requestBody?.content['application/json'];
    const inputs = [];
    const inputVariables = [];
    let returnType = null;

    serviceClassBody += '  /**\n';
    serviceClassBody += `   * ${description.trim().replaceAll('\n', '\n   * ')}\n`;
    serviceClassBody += '   *\n';

    for (const [ responseCode, responseData ] of Object.entries(responses)) {
      const responseDescription = responseData['description'] ?? '';

      if (responseData['content']) {
        const content = responseData['content'];
        const contentCode = parseInt(responseCode);
        const contentTypes = Object.keys(content);

        if (contentCode >= 200 && contentCode <= 299) {
          const contentSchema = content[contentTypes[0]].schema;
          const contentSchemaType = propertyToType(contentSchema);

          if (contentTypes.length > 1) {
            throw new Error(`Path ${path}, method ${method}, return code ${contentCode} has more than one content type for operation ${operationId}`);
          }

          if (returnType) {
            returnType += ` | ${contentSchemaType}`;
          } else {
            returnType = contentSchemaType;
          }

          if (contentSchemaType.endsWith('Dto')) {
            serviceDtoImports[contentSchemaType] = 1;
          } else if (contentSchemaType.indexOf('[')) {
            if (contentSchemaType.substring(0, contentSchemaType.indexOf('[')).endsWith('Dto')) {
              serviceDtoImports[contentSchemaType.substring(0, contentSchemaType.indexOf('['))] = 1;
            }
          }
        }
      }
    }

    for (const [ responseCode, responseData ] of Object.entries(responses)) {
      const responseDescription = responseData['description'] ?? '';

      serviceClassBody += `   * - Response code '${responseCode}': '${responseDescription.trim().replaceAll('\n', ' ')}'\n`;
    }

    if (parameters || requestBodyContent) {
      serviceClassBody += '   *\n';
    }

    if (parameters) {
      for (const parameter of parameters) {
        const { name, description, schema } = parameter;
        const inPath = parameter.in;

        if (inPath.toLowerCase() === 'path') {
          const parameterSchema = propertyToType(schema);

          if (parameterSchema.endsWith('Dto')) {
            serviceDtoImports[parameterSchema] = 1;
          } else if (parameterSchema.indexOf('[')) {
            if (parameterSchema.substring(0, parameterSchema.indexOf('[')).endsWith('Dto')) {
              serviceDtoImports[parameterSchema.substring(0, parameterSchema.indexOf('['))] = 1;
            }
          }

          if (description) {
            serviceClassBody += `   * @param ${name} ${description}\n`;
          } else {
            serviceClassBody += `   * @param ${name} (undocumented input parameter)\n`;
          }

          inputs.push(`@Param('${name}') ${name}: ${parameterSchema}`);
          inputVariables.push(`${name}: ${parameterSchema}`);
        }
      }
    }

    if (requestBodyContent) {
      const schema = requestBodyContent.schema;

      if (schema.$ref) {
        const reference = schema.$ref.substring(schema.$ref.lastIndexOf('/') + 1);

        inputs.push(`@Body() ${toCamelCase(reference)}Dto: ${reference}Dto`);
        inputVariables.push(`${toCamelCase(reference)}Dto: ${reference}Dto`);
        serviceDtoImports[`${reference}Dto`] = 1;

        if (requestBody.description) {
          serviceClassBody += `   * @param ${toCamelCase(reference)}Dto ${requestBody.description}\n`;
        }
      }
    }

    serviceClassBody += '   * @param request The express request object\n';
    serviceClassBody += '   */\n';
    serviceClassBody += `  ${operationId}(request: Request, ${inputVariables.join(', ')}): Promise<ServiceResponse<${returnType ?? 'null'}>>;\n\n`;
  }

  if (Object.keys(serviceDtoImports).length > 0) {
    serviceImports += `import { ${Object.keys(serviceDtoImports).join(', ')} } from '../dto';\n`;
  }

  serviceImports += 'import { ServiceResponse } from \'./index\';\n';
  serviceImports += 'import { Request } from \'express\';\n';

  serviceBody += serviceImports;
  serviceBody += '\n';
  serviceBody += `/**\n * ${description.trim().replaceAll('\n', '\n * ')}\n */\n`;
  serviceBody += `export interface ${name}Service {\n\n`;
  serviceBody += serviceClassBody;
  serviceBody += '}\n';

  fs.writeFileSync(serviceFile, serviceBody, 'utf8');
  console.log(`  - Wrote ${serviceFile}`);
}
