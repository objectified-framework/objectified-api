import {initCap, propertyToType, typeFormatter} from '../util';

const HEADER: string = `# This file is automatically generated.\n# Do not modify this file, any changes will be overwritten.\n#\n# Generated ${new Date()}\n\n`;

export function generateDtos(directory: string, openapi: any) {
  const schemas = openapi.components.schemas;
  const dtoDirectory = `${directory}/dto`;
  const fs = require('fs');

  fs.mkdirSync(dtoDirectory, { recursive: true });

  for(const dto of Object.keys(schemas)) {
    const { properties, description } = schemas[dto];
    const dtoFilename = `${dtoDirectory}/${dto}.py`;
    const dtoHeader = HEADER;
    const schemaDump = JSON.stringify(properties, null, 2)
        .replaceAll('\n', '\n# ')
        .replace(/"([^"]+)":/g, '$1:');
    let dtoBody = '';

    // Add header to the class definition
    dtoBody += dtoHeader;
    dtoBody += 'from typing import Any, Optional\n';
    dtoBody += 'from datetime import date, datetime\n';
    dtoBody += 'from pydantic import BaseModel, AnyUrl, SecretStr, EmailStr\n';
    dtoBody += 'from enum import Enum\n\n';

    dtoBody += '# JSON Schema:\n';
    dtoBody += `# ${schemaDump}\n\n`;

    dtoBody += generateEnumerations(schemas[dto]);

    dtoBody += `class ${dto}(BaseModel):\n`;
    dtoBody += `    """Template definition for \`${dto}\`: ${description.trim().replaceAll('\n', '\n    ')}"""\n\n`;
    dtoBody += generateSchema(schemas[dto]);

    fs.writeFileSync(dtoFilename, dtoBody, 'utf8');
    console.log(`  - Wrote ${dtoFilename}`);
  }
}

function generateEnumerations(schema: any): string {
  let body = '';
  const properties = schema.properties || {};

  if (schema.type.toLowerCase() === 'object') {
    for(const [key, val] of Object.entries(properties)) {
      const value = <any>val;

      if (value.enum) {
        body += `class ${initCap(key)}Enum(str, Enum):\n`;

        if (value.description) {
          body += `    """${value.description.trim()}"""\n`;
        } else {
          body += `    """${initCap(key)} Enumeration"""\n`;
        }

        for (const val of value.enum) {
          body += `    ${val} = '${val}'\n`;
        }

        body += '\n';
      }
    }
  }

  return body;
}

function generateSchema(schema: any): string {
  let body = '';
  const properties = schema.properties || {};
  const required = schema.required || [];

  if (schema.type.toLowerCase() === 'object') {
    for (const [key, val] of Object.entries(properties)) {
      const isRequired = required.includes(key);
      const value = <any>val;

      if (value.enum) {
        if (isRequired) {
          body += `    ${key}: ${initCap(key)}Enum`;
        } else {
          body += `    ${key}: Optional[${initCap(key)}Enum]`;
        }
      } else {
        if (isRequired) {
          body += `    ${key}: ${generateType(value)}`;
        } else {
          body += `    ${key}: Optional[${generateType(value)}]`;
        }
      }

      if (!isRequired) {
        body += ' = None';
      }

      body += '\n';

      if (value.description) {
        body += `    """${value.description.trim().replaceAll('\n', '\n    ')}"""\n`;
      }

      body += '\n';
    }

    if (schema.additionalProperties) {
      throw new Error('Unable to handle additionalProperties');
    }
  }

  return body;
}

function generateType(property: any): string {
  if (property.$ref) {
    return 'dtos.' + property.$ref.substring(property.$ref.lastIndexOf('/') + 1);
  }

  const lowerPropertyType = property.type.toLowerCase();

  if (lowerPropertyType === 'object') {
    if (property.properties) {
      return generateSchema(property.properties);
    }

    return 'Any';
  }

  if (lowerPropertyType === 'array') {
    return `list[${generateType(property.items)}]`;
  }

  if (lowerPropertyType === 'string') {
    if (property.format) {
      const lowerFormat = property.format.toLowerCase();

      if (lowerFormat === 'email') {
        return 'EmailStr';
      }

      if (lowerFormat.startsWith('uri')) {
        return 'AnyUrl';
      }

      if (lowerFormat === 'password') {
        return 'SecretStr';
      }

      if (lowerFormat === 'date-time') {
        return 'datetime';
      }

      if (lowerFormat === 'date') {
        return 'date';
      }

      return property.format;
    }

    if (property.enum) {
      return property.enum.toString();
    }

    return 'str';
  }

  if (lowerPropertyType === 'integer' || lowerPropertyType === 'number') {
    return 'int';
  }

  if (lowerPropertyType === 'double') {
    return 'complex';
  }

  if (lowerPropertyType === 'float') {
    return 'float';
  }

  if (lowerPropertyType === 'boolean') {
    return 'bool';
  }

  throw new Error(`Unknown type: ${JSON.stringify(property)}`);
}
